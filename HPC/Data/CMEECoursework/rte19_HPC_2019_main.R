# CMEE 2019 HPC excercises R code main proforma
# you don't HAVE to use this but it will be very helpful.  If you opt to write everything yourself from scratch please ensure you use EXACTLY the same function and parameter names and beware that you may loose marks if it doesn't work properly because of not using the proforma.

name <- "Ryan Ellis"
preferred_name <- "Ryan"
email <- "ryan.ellis19@imperial.ac.uk"
username <- "rte19"
personal_speciation_rate <- 0.002 # will be assigned to each person individually in class and should be between 0.002 and 0.007

# Question 1
species_richness <- function(community){
  return(length(unique(community))) #Counts the unique species in the community
}

# Question 2
init_community_max <- function(size){
  return(seq(size)) #Returns the most diverse community for that size
}

# Question 3
init_community_min <- function(size){
  return(seq(size) ^ 0) #returns the least diverse community for that size
}

# Question 4
choose_two <- function(max_value){
  return(sample(1:max_value, 2, replace = FALSE)) #Chooses two individuals from a communtiy at random
}

# Question 5
neutral_step <- function(community){
  choice <- choose_two(length(community)) #Chooses two individuals at random
  community[choice[1]] <- community[choice[2]] #One individual dies and one individual reproduces
  return(community)
}

# Question 6
neutral_generation <- function(community){
  if( length(community) %% 2 == 0){  #If the communtiy size is even
    gen <- length(community) / 2 #A generation is carried out with the number of neutral steps being half the number of individuals in the community
  }
  else{
    gen <- (length(community) + sample(c(-1,1), size = 1)) / 2 #If the number of individuals in the communtiy is odd, then we randomly take round up or down to the nearest even numer, to avoid a bias. And work out generation as before
  }
  for( i in 1:gen){
    community <- neutral_step(community) #Carrying out the amount of neutral steps within the generation
  }
  return(community)
}

# Question 7
neutral_time_series <- function(community,duration)  {
  richness.series <- species_richness(community) #Obtaining species richness of initial communtiy
  for( i in 1:duration){ #Duration specifies the number of neutral generations we take
    community <- neutral_generation(community) #Working out state of commntiy after one generation
    richness.series <- c(richness.series, species_richness(community)) #Recording the species richness of each generation over the time period, in a vector
  }
return(richness.series)
}

# Question 8
question_8 <- function() {
  graphics.off() #Clearing existing graphs
  community <- init_community_max(100) #Initial community with maximum diversity of 100 species
  duration <- 200 #200 generations
  ydata <- neutral_time_series(community, duration) #Assinging the vector containing all the species richness to the y data
  xdata <- c(0, seq(duration)) #Making the duration of the generations the x data
  plot(ydata ~ xdata, ylab = "Species richness", xlab = "Generation") #Plotting
  return("With enough generations, the system will always converge to a system of only one species. This is because of the stochastic nature of the system, one will always dominate in the end.")
}

# Question 9
neutral_step_speciation <- function(community,speciation_rate)  { #My favourite function
  speciation <- sample(c(1, 0), size = 1, prob = c(speciation_rate, 1 - speciation_rate)) #Probability of choosing one is the speciation probablity, and of choosing 0 is the remaining probability
  if( speciation == 1){
    species <- max(unique(community)) + 1 #A unique species is generated by taking the maximum species in=dentifying m=number and simply adding 1 to it
    choice <- choose_two(length(community)) #Choosing two individuals at random
    community[choice[1]] <- species #If speciation is 1, then an exisitng individual of the community becomes a speciated individual
  }
  else{
    choice <- choose_two(length(community)) #Choosing two individuals at random
    community[choice[1]] <- community[choice[2]] #If speciation is 0, then no speciation occurs and one individual dies, and one reproduces
  }
  return(community)
}

# Question 10
neutral_generation_speciation <- function(community,speciation_rate)  {
  if( length(community) %% 2 == 0){ 
    gen <- length(community) / 2 #If the number of individuals in the communtiy is even, then generation is this number halved 
  }
  else{
    gen <- (length(community) + sample(c(-1,1), size = 1)) / 2 #If it is not even, then the number of individuals in the communtiy is randomly rounded up or down to the earest even, to prevent bias, and then halved to make the generation 
  }
  for( i in 1:gen){
    community <- neutral_step_speciation(community, speciation_rate) #Generation is given by the number of neutral step speciations that need to take place to complete one generation. 
  }
  return(community)
}

# Question 11
neutral_time_series_speciation <- function(community,speciation_rate,duration)  { 
  richness.series <- species_richness(community) #Obtaining species richness of initial communtiy
  for( i in 1:duration){ #Duration specifies the number of neutral generations we take
    community <- neutral_generation_speciation(community, speciation_rate) #Working out state of commntiy after one generation with possibility of speciation
    richness.series <- c(richness.series, species_richness(community)) #Recording the species richness of each generation over the time period, in a vector
  }
  return(richness.series)
}

# Question 12
question_12 <- function()  {
  # clear any existing graphs and plot your graph within the R window
  graphics.off() #Clearing existing graphs
  community.max <- init_community_max(100) #Initial community with maximum diversity of 100 species
  community.min <- init_community_min(100) #Initial community with miminum diversity of 100 species
  duration <- 200 #200 generations
  speciation_rate <- 0.1 
  ydata1 <- neutral_time_series_speciation(community.max, speciation_rate, duration) #Assinging the vector containing all the species richness to the y data, starting with max community
  ydata2 <- neutral_time_series_speciation(community.min, speciation_rate, duration) #Assinging the vector containing all the species richness to the y data, starting with min communtiy
  xdata <- c(0, seq(duration)) #Making the duration of the generations the x data
  plot(ydata1 ~ xdata, ylab = "Species richness", xlab = "Generation", col = "green", type = "l") #Plotting
  lines(ydata2 ~ xdata, col = "blue") #More Plotting
  legend(5, 95, legend = c("Initial max community", "Initial min community"), col = c("green", "blue"), lty = 1) #Adding legends
  return("With an initial community maximum, within the first few generations the species richness dramatically reduces. This reduction in species richness thereafter fluctuates around a steady state. This is due to species continually being out competed but because of the high number of individuals, the species richness can be rescued by speciation. 
         However, when we start with a initial community minimum, due to there being a high number of individuals, speciation occurs at the beginning, raising the species richness. Once the species richness reaches a certain level however, it too fluctuates around a steady state, maintind by the opposing forces of speciation and extinction. 
         The self sustaining oscillations of both comunities is in the long term very similar, given the fact that they are bound by identical parameters of population size and speciation rate.")
}

# Question 13
species_abundance <- function(community)  {
  abundance_vector <- sort(table(community), decreasing = TRUE) #tables are just vectors with added labels and frills. 
  return(as.vector(abundance_vector)) #Counts how many individuals are in each species within the community and returns them in descending order
}

# Question 14
octaves <- function(abundance_vector) {
  max <- max(abundance_vector) #Getting the maxmum number from the abbndance vector
  n <- seq(ceiling(log10(max) / log10(2))) #Working out how many n it takes to get the max in terms of 2^n. Then rounding up every time to get an integer value to work out the iggest octave bin needed
  upper <- c()
  lower <- c()
  for(i in n){
    upper <- c(upper, 2 ^ (i)) #Working out all the upper limit octave bins for the species abundance
    lower <- c(lower, 2 ^ (i - 1)) #Working out all the lower limit octave bins for the species abundance
  }
  octave.vector <- c()
  for( j in 1:length(lower)){
    octave.vector <- c(octave.vector, length(which(abundance_vector >= lower[j] & abundance_vector < upper[j])))
  } #Counting how many soecies abbudances fit into each octave bin, being equal to and greater than lower limit, and less than upper limit. So the total number of species with only one individul in them appears in the first in
  return(octave.vector)
}
#>= 2^(n-1) 1 2 4 8  16 32 64  128 first eight lower limits
#<  2^n     2 4 8 16 32 64 128 256 first eight upper limits

# Question 15
sum_vect <- function(x, y){
  xlength <- length(x) #Working out length of vector x
  ylength <- length(y) #working out length of vector y
  if( xlength == ylength){
    sumvect <- x + y #If their lengths are the same, then add normally
  }
  else if( xlength < ylength){ #If length of x is less than y
    dif <- seq(ylength - xlength) #Work out difference
    for( i in dif){
      x <- c(x, 0) #Add in as many zeros to vector x as is the difference in lengths
    sumvect <- x + y #Then add the vectors
    }
  }
  else{
    dif <- seq(xlength - ylength) #If length of vector y is less than x
    for( i in dif){ #Then work out difference
      y <- c(y, 0) #Add on as many zeros to vector y as is in the difference
    }
    sumvect <- x + y #Then add the vectors together
  }
  return(sumvect)
}

# Question 16 
question_16 <- function()  {
  graphics.off() 
  community.max <- init_community_max(100) #Max diversity species of communtiy size 100
  community.min <- init_community_min(100) #Min diversity species of communtiy size 100
  burnin <- 200
  speciation_rate <- 0.1
  for( i in 1:burnin){ #Working out the community compositions after the burn in number of generations
    community1 <- neutral_generation_speciation(community = community.max, speciation_rate = speciation_rate)
    community2 <- neutral_generation_speciation(community = community.min, speciation_rate = speciation_rate)
  }
  octave.vector1 <- octaves(species_abundance(community1)) #Working out the octave vector of each community
  octave.vector2 <- octaves(species_abundance(community2))
  
  generations <- 2000 #Then for anoter 2000 generations
  record.every <- 20 #Recording sum of the octave bins every 20 generations
  octave.vector1.sum <- octave.vector1 #Initial sum after burn in
  octave.vector2.sum <- octave.vector2
  for( j in 1:(generations/record.every)){ 
    for( k in 1:record.every){
      community1 <- neutral_generation_speciation(community = community1, speciation_rate = speciation_rate) #Pausing the community composition every 20 generations, to add this value onto the rest
      community2 <- neutral_generation_speciation(community = community2, speciation_rate = speciation_rate)
    }
      octave.vector1.sum <- sum_vect(octave.vector1.sum, octaves(species_abundance(community1))) #Recording the sum of all the octaves for the 2000 genrations, every 20 generations, for each community
      octave.vector2.sum <- sum_vect(octave.vector2.sum, octaves(species_abundance(community2)))
  }
  octave.vector1.av <- octave.vector1.sum/(generations/record.every) #Taking the average octave vector for the 2000 generations post burn in
  octave.vector2.av <- octave.vector2.sum/(generations/record.every)
  
  length1 <- length(octave.vector1.av) #Taking the lengths of the average octave vectors
  length2 <- length(octave.vector2.av)
  if( length1 != length2){ #If the lengths are not the same (which is needed for plotting), then add zeros onto the one with fewest vlues, to make them both the same length
    if( length1 < length2){
      dif <- length2 - length1
      for( n in seq(dif)){
        octave.vector1.av <- c(octave.vector1.av, 0)
      }
    }
    else{
      dif <- length1 - length2
      for( n in seq(dif)){
        octave.vector2.av <- c(octave.vector2.av, 0)
      }
    }
  }
  my.df <- data.frame(initial_community_max = octave.vector1.av, #Making a dataframe of the average octave vectors
                      initial_community_min = octave.vector2.av)
  barplot(t(as.matrix(my.df)), #Plotting the data in a boxplot
          beside = TRUE, #placing the ars besid each other
          legend.text = TRUE, #Legend
          args.legend = list(x = "topright", bty="n", inset=c(-0.10,0), xpd = TRUE)) #Telling legend to be in the top right and allowed to be outside the graph if need be
  
  return("The initial condition of the community, whether it is a communtiy maximum or minimum makes no difference to the average state of the community after 200 years, for the next 2000 years.
         This is because ultimately the two communities are governed by the same population size and speciation rate. This means that the opposing forces for speciation and extinction will reach a dynamic equilibrium the same in both communities, given enough time.")
}

# Question 17
cluster_run <- function(speciation_rate, size, wall_time, interval_rich, interval_oct, burn_in_generations, output_file_name)  {
  community <- init_community_min(size)
  start.time <- proc.time()[[3]] #Initialising start time
  wall_time2 <- wall_time * 60 * 60 #From hours to seconds
  generations <- 0 #Initialising generations
  abundance.octaves <- list(octaves(species_abundance(community))) #Initialising abundance.octaves as a list to hold all the created abundance octave vectors, but first taking the intial abundance octave
  time_series <- species_richness(community) #Initilising the time_series as a vector to hold all the species richnesses, but first taking taking the intial richnes
  end.time <- start.time #Initialing end time the same as start for the begning
  while( (end.time - start.time) < wall_time2){ #Setting up the timer. When the difference in end time and start is equal to wall_time in seconds, the looping stops
    generations <- generations + 1 #Every loop is the next generation
    community <- neutral_generation_speciation(community, speciation_rate) #Community evolves each generation
    if( generations %% interval_oct == 0){ 
      abundance.octaves[length(abundance.octaves) + 1] <- list(octaves(species_abundance(community))) #Takes abundance octave ever time the generations are a multiple of interval_oct
    }
    if( burn_in_generations >= generations){ #If generations is within burn in time
      if( generations %% interval_rich == 0){
        time_series <- c(time_series, species_richness(community)) #Take the species richness when generation is a multiple of interval_rich
      }
    }
    end.time <- proc.time()[[3]] #After every loop the end time is recalculated
  }
  total_time <- end.time - start.time #Work out the total time spent on this function
  save(time_series, abundance.octaves, community, total_time, speciation_rate, size, wall_time, interval_rich, interval_oct, burn_in_generations, file = paste(output_file_name)) #Saving all the data measured
}

# Questions 18 and 19 involve writing code elsewhere to run your simulations on the cluster

# Question 20 
process_cluster_results <- function()  {
  # clear any existing graphs and plot your graph within the R window
  graphics.off()
  allfiles <- list.files(pattern = "*.rda") #Lisitng all the files
  abundance500numerator <- c() #Initialising the numerator for mean abundance octae vector for size 500
  abundance500denominator <- 0 #Initialising the demonminator for mean abundance octae vector for size 500
  abundance1000numerator <- c() #Initialising the numerator for mean abundance octae vector for size 500
  abundance1000denominator <- 0 #Initialising the demonminator for mean abundance octae vector for size 500
  abundance2500numerator <- c() #Initialising the numerator for mean abundance octae vector for size 500
  abundance2500denominator <- 0 #Initialising the demonminator for mean abundance octae vector for size 500
  abundance5000numerator <- c() #Initialising the numerator for mean abundance octae vector for size 500
  abundance5000denominator <- 0 #Initialising the demonminator for mean abundance octae vector for size 500
  
    for( i in 1:100){
    load(allfiles[i]) #loading each file at a time
    if( size == 500){ #If the community size is 500
      cut <- burn_in_generations/interval_oct #Working out how many are in the burn in time to ignore
      abundance500denominator <- length(abundance.octaves) - cut + abundance500denominator #Cummulatively add up how many abundance octave vectors we are using
      for( j in (cut+1):length(abundance.octaves)){
        abundance500numerator <- sum_vect(abundance500numerator, abundance.octaves[[j]]) #Addin up all the wanted abundance octave vectors
      }
    }
    if( size == 1000){ #If the community size is 1000
      cut <- burn_in_generations/interval_oct #Working out how many are in the burn in time to ignore
      abundance1000denominator <- length(abundance.octaves) - cut + abundance1000denominator #Cummulatively add up how many abundance octave vectors we are using
      for( j in (cut+1):length(abundance.octaves)){
        abundance1000numerator <- sum_vect(abundance1000numerator, abundance.octaves[[j]]) #Addin up all the wanted abundance octave vectors
      }
    }
    if( size == 2500){ #If the community size is 2500
      cut <- burn_in_generations/interval_oct #Working out how many are in the burn in time to ignore
      abundance2500denominator <- length(abundance.octaves) - cut + abundance2500denominator #Cummulatively add up how many abundance octave vectors we are using
      for( j in (cut+1):length(abundance.octaves)){
        abundance2500numerator <- sum_vect(abundance2500numerator, abundance.octaves[[j]]) #Addin up all the wanted abundance octave vectors
      }
    }
    if( size == 5000){ #If the community size is 5000
      cut <- burn_in_generations/interval_oct #Working out how many are in the burn in time to ignore
      abundance5000denominator <- length(abundance.octaves) - cut + abundance5000denominator #Cummulatively add up how many abundance octave vectors we are using
      for( j in (cut+1):length(abundance.octaves)){
        abundance5000numerator <- sum_vect(abundance5000numerator, abundance.octaves[[j]]) #Addin up all the wanted abundance octave vectors
      }
    }
  }
  abundance500mean <- abundance500numerator/abundance500denominator #Working out my average abundance octave vectors
  abundance1000mean <- abundance1000numerator/abundance1000denominator
  abundance2500mean <- abundance2500numerator/abundance2500denominator
  abundance5000mean <- abundance5000numerator/abundance5000denominator
    
  par(mfrow=c(2,2)) #2x2 panel of barplots
  barplot(abundance500mean, xlab = "Community size = 500", ylab = "Abundance") #Plotting the barplot for the mean aundance octave vector for community size of 500
  barplot(abundance1000mean, xlab = "Community size = 1000", ylab = "Abundance") #Plotting the barplot for the mean aundance octave vector for community size of 1000
  barplot(abundance2500mean, xlab = "Community size = 2500", ylab = "Abundance") #Plotting the barplot for the mean aundance octave vector for community size of 2500
  barplot(abundance5000mean, xlab = "Community size = 5000", ylab = "Abundance") #Plotting the barplot for the mean aundance octave vector for community size of 5000
  
  combined_results <- list(abundance500mean, abundance1000mean, abundance2500mean, abundance5000mean) #create your list output here to return
  save(abundance500mean, abundance1000mean, abundance2500mean, abundance5000mean, file = "rte19_cluster_results.rda")
  
  return(combined_results)
}

# Question 21
question_21 <- function()  {
  x <- log10(8)/log10(3)
  return(x, "For each repeating unit there is 8 repeating units inside, with 3 of them on one perimeter line.")
}

# Question 22
question_22 <- function()  {
  x <- log10(20)/log10(3)
  return(x, "For each repeating unit there is 20 repeating units inside, with 3 of them on one perimeter line.")
}

# Question 23
chaos_game <- function()  {
  graphics.off()
  #Storing point vectors
  A <- c(0,0)
  B <- c(3,4)
  C <- c(4,1)
  X <- c(0,0)
  
  #plotting a very small point on a graph
  plot(1, type = "n", xlab = "", ylab = "", xlim = c(0,4), ylim = c(0,4))
  
  
  #plotting at random half way to each of the three coordinates, rep number of times
  coords <- list(A, B, C)
  rep <- 100000
  for( i in 1:rep){
    points(X[1], X[2], cex = 0.01)
    rancoord <- sample(coords, size = 1)
    X <- (X + rancoord[[1]])/2
    #points(toplot[1], toplot[2], cex = 0.1)
  }
  return("A Lipinski triangle")
}

# Question 24
turtle <- function(start_position, direction, length)  {
  end_x <- start_position[1] + (length * sin(direction)) #working out x2 using soh
  end_y <- start_position[2] + (length * cos(direction)) #working out y2 using cah
  end_position <- c(end_x, end_y) #end position coordinate
  
  line <- cbind(start_position, end_position) #making matrix contining each starting and ending cordinate in its own row
  lines(line[1,], line[2,]) #plotting the line
  
  return(end_position) # you should return your endpoint here.
}

# Question 25
elbow <- function(start_position, direction, length)  {
  new <- turtle(start_position, direction, length) #drawing the first line and saving the output, the end coordinate
  turtle(new, direction + pi/4, length*0.95) #drawing the second line quater pi to the right, with the starting coordinate as the end one from before and 0.95 the length
}

# Question 26
spiral <- function(start_position, direction, length)  {
  new <- turtle(start_position, direction, length) #Draws the first line
  if( length > 0.01){
    spiral(new, direction + pi/4, length*0.95) #Recursively calls itself so that it makes the spiral
    return("The function is now recursive, it calls itself. This gives the indefinite spiral while the length > 0.01.")
  }
}

# Question 27
draw_spiral <- function()  {
  graphics.off()
  plot(1, type = "n", xlab = "", ylab = "", xlim = c(0,4), ylim = c(0,4)) #Openning up a blank graph
  spiral <- spiral(c(1,1), 2*pi, 1) #plots te spiral
  return(spiral) #returns the same output as before
}

# Question 28
tree <- function(start_position, direction, length)  {
  new <- turtle(start_position, direction, length) #Draws the first line
  if( length > 0.01){
    tree(new, direction + pi/4, length*0.65) #Recursively calls itself so that it makes half the tree
    tree(new, direction - pi/4, length*0.65) #Recursively calls itself so that it makes half the tree
  }
}
draw_tree <- function()  {
  graphics.off()
  plot(1, type = "n", xlab = "", ylab = "", xlim = c(-4,4), ylim = c(0,4)) #Openning up a blank graph
  tree(c(1,1), 2*pi, 1)
}

# Question 29
fern <- function(start_position, direction, length)  {
  new <- turtle(start_position, direction, length) #Draws the lines
  if( length > 0.01){
    fern(new, direction, length*0.87) #Recursively calls itself so that it makes half the fern
    fern(new, direction - pi/4, length*0.38) #Recursively calls itself so that it makes half the fern
  }
}
draw_fern <- function()  {
  graphics.off()
  plot(1, type = "n", xlab = "", ylab = "", xlim = c(-4,4), ylim = c(0,10)) #Openning up a blank graph
  fern(c(1,1), 2*pi, 1)
}

# Question 30
fern2 <- function(start_position, direction, length, dir)  {
  new <- turtle(start_position, direction, length) #Draws the lines  
  if( length > 0.01){ 
    if( dir == -1){ #if dir == -1, then we go up and left. The dir alternates between 1 and -1
      fern2(new, direction, length*0.87, dir*-1) #Recursively calls itself so that it makes the fern, but switches dir
      fern2(new, direction - pi/4, length*0.38, dir*-1) #Recursively calls itself so that it makes the left half of the fern, but switches dir for afterwards
    }
    else{ #If dir == 1, then we go up and right
      fern2(new, direction, length*0.87, dir*-1) #Recursively calls itself so that it makes the right half of the fern, but switches dir for afterwards
      fern2(new, direction + pi/4, length*0.38, dir*-1) #Recursively calls itself so that it makes the fern, but switches dir for afertwrards
    }
  }
}
draw_fern2 <- function()  {
  graphics.off()
  plot(1, type = "n", xlab = "", ylab = "", xlim = c(-4,4), ylim = c(0,10)) #Openning up a blank graph
  fern2(c(1,1), 2*pi, 1, -1)
}

# Challenge questions - these are optional, substantially harder, and a maximum of 16% is available for doing them.  

# Challenge question A
Challenge_A <- function() {
  # clear any existing graphs and plot your graph within the R window
}

# Challenge question B
Challenge_B <- function() {
  # clear any existing graphs and plot your graph within the R window
}

# Challenge question C
Challenge_C <- function() {
  # clear any existing graphs and plot your graph within the R window
}

# Challenge question D
Challenge_D <- function() {
  # clear any existing graphs and plot your graph within the R window
  return("type your written answer here")
}

# Challenge question E
Challenge_E <- function() {
  # clear any existing graphs and plot your graph within the R window
  return("type your written answer here")
}

# Challenge question F
Challenge_F <- function() {
  # clear any existing graphs and plot your graph within the R window
  return("type your written answer here")
}

# Challenge question G should be written in a separate file that has no dependencies on any functions here.


